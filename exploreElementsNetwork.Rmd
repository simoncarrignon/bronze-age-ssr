---
title: "Network Analysis for Ancient Metallurgy and Beyond: Statistical synthesis of contextual, typological, technological and geochemical data"
author: "SC"
date: "12/2021"
output: 
    bookdown::html_document2:
        code_folding: show
        section_numbers: true
        toc: true

---

# R-version of Community structure of copper supply networks in the prehistoric Balkans: An independent evaluation of the archaeological record from the 7th to the 4th millennium BC


## Artefact Network

### Get Data


```{r,initialisation}
knitr::opts_chunk$set(warning=FALSE,message=FALSE,cache=FALSE,collapse=TRUE,fig.show="hold",results="hide")
```

Code Jelena other comnunity bipartite between metal mix and artefact
4thousand years
20000-30000

Get the data 

```{r}
epsilon=0.0001
datappm=read.csv("Table S1.csv")
datappm[datappm==0.0001]=epsilon
ppms=datappm[,15:21]  #select only a subset of the elements
plot(ppms,pch=20,cex=.7,col=adjustcolor(1,.2))
```

Check the correaltion between the elements' ppm

```{r,results="asis"}
knitr::kable(cor(ppms)) #this is to show correlation between elements
```

### Log transform

```{r}
ppms=as.data.frame(apply(ppms,2,log)) #take the log of the elements trace
plot(ppms,pch=20,cex=.7,col=adjustcolor(1,.2))
```

Check the correlations between ppms when log transformed

```{r,results="asis"}
knitr::kable(cor(ppms))
```

### PCA -dimenstion reduction

Compute PCA scores:

```{r}
ppms.pca=prcomp(ppms) #compute the PCA
ppms.dist=dist(ppms.pca$x) #compute distance between PCA scores
ppms.clust=hclust(ppms.dist,method="ward.D") #generate hierarchical cluster given the distances
ppms.kclust=cutree(ppms.clust,k=10) #playing comparing community cluster vs simple hierarchical clustering

plot(ppms.pca$x[,1:2],col=rainbow(10)[datappm$Chemical.cluster+1]) #plot the pca score and colors given the cluster found in the original paper
points(ppms.pca$x[,1:2],col=rainbow(10)[ppms.kclust],pch=20  )#plot the pca score and colors given hierarchical clustering 

#legend("topright",legend=paste0("Cluster #",1:10),pch=1,col=rainbow(10),title="original clusters")
#legend("bottomright",legend=paste0("Cluster #",1:10),pch=20,col=rainbow(10),title="hclust clusters")
```

We now transform the result of the PCA as a graph, we compute edge weights as 
$$ \sqrt{\sum\frac{1}{d^2}} $$


### Network reconstruction

```{r}

library(igraph)
ppms.ew=1/(as.matrix(ppms.dist)^2) #Generate edges given the distance computed via the PCA scores
ppms.graph=graph.adjacency(ppms.ew, mode = "undirected", weighted = TRUE, diag = FALSE) #generate a graph


## the lines below are used to set graphical option
V(ppms.graph)$label=as.character(datappm$Site)
V(ppms.graph)$label.cex=.4
V(ppms.graph)$size=8
V(ppms.graph)$frame.color="black"
V(ppms.graph)$frame.width=.5
V(ppms.graph)$label.color="black"
E(ppms.graph)$color=NA
####################################

ppms.graph=set_graph_attr(ppms.graph,"layout",layout_nicely(ppms.graph)) #generate a layout to position the node 
plot(ppms.graph) #plot the graph
```

Use this graph to  compute the communities

```{r louvain,results="hold",fig.cap="simple visualisation of the network with louvain communities. We label node given the site (left) and site + period (right)  where the artefact has been found.",out.width="50%"}
par(mar=c(0,0,0,0))
ppms.louvain=cluster_louvain(ppms.graph)
#weirdly now louvain community structues gives only one set of 10 clusters
#while(length(table(ppms.louvain$memberships[1,]))!=10){ppms.louvain=cluster_louvain(ppms.graph);print(length(table(ppms.louvain$memberships[1,])))}
#ppms.louvain=multilevel.community(ppms.graph)
counts=as.data.frame(sort(table(ppms.louvain$membership)))
colnames(counts)=c("community","size")
knitr::kable(counts)
plot(ppms.graph,vertex.color=rainbow(length(ppms.louvain),alpha=.6)[ppms.louvain$membership])

plot(ppms.graph,vertex.color=rainbow(length(ppms.louvain),alpha=.6)[ppms.louvain$membership],vertex.label=paste(datappm$Site,datappm$relative.period,sep="-"))
```

Looks like the `cluster_louvain` function return only the "first level" mentionned in the original paper, with 6 communities. Other level are given in `$memberships` but they don't exactly match original results

```{r ,results="asis",fig.cap="visualisation of the network with louvain communities of the second level. We label node given the site (left) and site + period (right)  where the artefact has been found.",out.width="50%"}
par(mar=c(0,0,0,0))

nc=length(unique(ppms.louvain$memberships[1,]))
plot(ppms.graph,vertex.color=rainbow(nc,alpha=.6)[ppms.louvain$memberships[1,]])

plot(ppms.graph,vertex.color=rainbow(length(ppms.louvain),alpha=.6)[ppms.louvain$memberships[1,]],vertex.label=paste(datappm$Site,datappm$relative.period,sep="-"))
```
Lets compare the communites found

```{r,results="asis",out.width="10%",fig.show="hold",fig.pos="top"}
options(width=50)
counts1=as.data.frame(sort(table(ppms.louvain$memberships[1,]),decreasing=T))
counts2=as.data.frame(sort(table(ppms.louvain$memberships[2,]),decreasing=T))
orig=as.data.frame(sort(table(datappm$Chemical.cluster),decreasing=T))
colnames(orig)=colnames(counts1)=colnames(counts2)=c("community","size")
allcounts=list(counts1,counts2,orig)
mxrow=max(sapply(allcounts,nrow))
addrow <- function(tbl,newmax){
    if(nrow(tbl)<newmax)
        tbl[(nrow(tbl)+1):newmax,]=NA;
    tbl
}
allcounts=lapply(allcounts,addrow,newmax=mxrow)

knitr::kables(lapply(allcounts,knitr::kable))
#knitr::kables(lapply(lapply(list(counts1,counts2,orig),knitr::kable),kableExtra::kable_styling))
```


```{r,results="hold"}
# jelena 4 is  R louvain 3
# jelena 2 is  R louvain 1
# jelena 9 is  R louvain 2

sum(datappm$Chemical.cluster==0 & ppms.louvain$membership ==4)
sum(datappm$Chemical.cluster==1 & ppms.louvain$membership ==5)
sum(datappm$Chemical.cluster==2 & ppms.louvain$membership ==1)
sum(datappm$Chemical.cluster==4 & ppms.louvain$membership ==3)
sum(datappm$Chemical.cluster==5 & ppms.louvain$membership ==6)
sum(datappm$Chemical.cluster==9 & ppms.louvain$membership ==2)
```


Visual comparisaion of the communities, it's clearly the same.


```{r compareOldNewResults,out.width="50%",fig.cap="Communities detected through louvain algorithm. Left: R `cluster_louvain` result. Right: Original paper results (level2 louvain results)."}
par(mar=c(0,0,0,0))
plot(ppms.graph,vertex.color=rainbow(6,alpha=.6)[ppms.louvain$membership])
plot(ppms.graph,vertex.color=rainbow(10,alpha=.6)[datappm$Chemical.cluster+1])
```

```{r compareOldNewResultsLvl2,out.width="50%",fig.cap="Communities detected through louvain algorithm. Left: R `cluster_louvain` result. Right: Original paper results (level2 louvain results)."}
par(mar=c(0,0,0,0))
plot(ppms.graph,vertex.color=rainbow(nrow(counts1),alpha=.6)[ppms.louvain$memberships[2,]])
plot(ppms.graph,vertex.color=rainbow(10,alpha=.6)[datappm$Chemical.cluster+1])
```

Rough geo illustration


```{r out.width="50%",fig.cap="latlon"}
latitude=as.numeric(gsub("[' \\\"N]","",gsub("Â°",".",gsub("\\.","",datappm$Geo.Latitude))))
longitude=as.numeric(gsub("[' \\\"E]","",gsub("Â°",".",gsub("\\.","",datappm$Geo.Longitude))))
plot(longitude ,latitude,bg=rainbow(6,alpha=.6)[ppms.louvain$membership],pch=21,cex=1.2)
text(longitude ,latitude,datappm$Site,cex=.7)
plot(longitude ,latitude,bg=rainbow(10,alpha=.6)[datappm$Chemical.cluster],pch=21,cex=1.2)
text(longitude ,latitude,datappm$Site,cex=.7)
```

## Sites Network

Count how many artefacts from each community sites share. We will use a simple match function (total number of similar communities):

```{r}
simpmatch  <-  function(i,j){
    if(length(i)>length(j)){
        tmp=i
        i=j
        j=tmp
    }
    length(na.omit(match(i,j)))
}
```




```{r}
joined=cbind(datappm,louvain=ppms.louvain$membership)
sites=unique(joined$Site)

system.time({
matdim1=sapply(sites,function(s1) sapply(sites,function(s2) simpmatch(joined$louvain[ joined$Site == s1],joined$louvain[ joined$Site == s2])))
})

system.time({
matdim2=matrix(NA,nrow=80,ncol=80)
for(s1 in 1:length(sites)){
    for(s2 in 1:length(sites)){
        c1=joined$louvain[ joined$Site == sites[s1]]
        c2=joined$louvain[ joined$Site == sites[s2]]
        matdim2[s1,s2]=simpmatch(c1,c2)
    }
}
})
sum(matdim2-matdim1)

sites.graph=graph.adjacency(matdim1, mode = "undirected", weighted = TRUE, diag = FALSE)
V(sites.graph)$label=as.character(sites)
V(sites.graph)$label.cex=.7
V(sites.graph)$size=8
V(sites.graph)$label.color="black"
E(sites.graph)$color=NA
sites.graph=set_graph_attr(sites.graph,"layout",layout_nicely(sites.graph))
plot(sites.graph)

```

Compute communities of sites:

```{r}
sites.communities=cluster_louvain(sites.graph)
plot(sites.graph,vertex.color=rainbow(length(sites.communities),alpha=.6)[sites.communities$membership])
plot(longitude ,latitude,bg=rainbow(length(sites.communities),alpha=.6)[sites.communities$membership],pch=21,cex=1.2)
text(longitude ,latitude,joined$siteperiod,cex=.7)
```

### Site-period

```{r}
par(mar=c(0,0,0,0))
siteperiod=paste0(datappm$Site,datappm$absolute.period)
joined=cbind(joined,siteperiod)

sites=unique(joined$siteperiod)
matSP=sapply(sites,function(s1) sapply(sites,function(s2) simpmatch(joined$louvain[ joined$siteperiod == s1],joined$louvain[ joined$siteperiod == s2])))

sites.graph=graph.adjacency(matSP, mode = "undirected", weighted = TRUE, diag = FALSE)
V(sites.graph)$label=as.character(sites)
V(sites.graph)$label.cex=.7
V(sites.graph)$size=8
V(sites.graph)$frame.color="black"
V(sites.graph)$frame.width=.5
V(sites.graph)$label.color="black"
E(sites.graph)$color=NA
sites.graph=set_graph_attr(sites.graph,"layout",layout_nicely(sites.graph))
sites.communities=cluster_louvain(sites.graph)
plot(sites.graph,vertex.color=rainbow(length(sites.communities),alpha=.6)[sites.communities$membership])

plot(longitude ,latitude,bg=rainbow(length(sites.communities),alpha=.6)[sites.communities$membership],pch=21,cex=1.2)
text(longitude ,latitude,joined$siteperiod,cex=.7)
```

Compare the communities found with original results:
,

```{r,results="asis"}
orig=read.csv("Table S2.csv")
orig$Modularity.No.=orig$Modularity.No.+1
newds=cbind.data.frame(Label=V(sites.graph)$label,newcommunities=sites.communities$membership)
merged=merge(orig[,c("Label","Modularity.No.")],newds )
kbl=knitr::kable(merged)
kableExtra::row_spec(kbl,which(merged[,2]!=merged[,3]) , background = "red")
```


# New dataset


## Artefact Network

### Get Data


```{r}
datappm=read.csv("data/SEALIP_BROGLASEA data_Pryce.csv")

# set an arbitrary epsilon value and replace "tr"s and "0"s with it
epsilon=0.0001
datappm[,12:42]=apply(datappm[,12:42],2,function(i){i[i=="tr"]=epsilon;as.numeric(i)})
datappm[,12:42]=apply(datappm[,12:42],2,function(i){i[i==0]=epsilon;as.numeric(i)})


ppms=datappm[,12:42]
listelements=c("Sb","Sn","Ag","Mo","Bi","Pb","Se","As","Au","Zn","Cu","Ni","Co")
ppms=datappm[,listelements]
#ppms=ppms[,-7]
artnull=which(apply(ppms,1,sd)==0)
artnull=c(222,289,296,299,531,172,181,531)
datappm=datappm[-artnull,]
ppms=ppms[-artnull,]
#plot(ppms,pch=20,cex=.7,col=adjustcolor(1,.2))
```

Check the correaltion between the elements' ppm

```{r,results="asis"}
knitr::kable(cor(ppms))
```

### Log transform

```{r}
ppms=as.data.frame(apply(ppms,2,log))
#plot(ppms,pch=20,cex=.7,col=adjustcolor(1,.2))
```

Check the correlations between ppms when log transformed

```{r,results="asis"}
knitr::kable(cor(ppms))
```

### PCA - dimeension reduction

Compute PCA scores:

```{r pcafig,fig.cap="cluster using directly the PCA result",out.width="50%"}
# remove eelement poorly detected
#ppms=ppms[,apply(ppms,2,function(i)sum(i==log(epsilon)))<(.4*nrow(ppms))]

ppms.pca=prcomp(ppms)
ppms.dist=dist(ppms.pca$x)
ppms.clust=hclust(ppms.dist)
ppms.kclust=cutree(ppms.clust,k=10) #playing comparing community cluster vs simple hierarchical clustering
plot(ppms.pca$x[,1:2],col=ppms.kclust,pch=20  )
plot(ppms.pca$x[,1:2],col=ppms.kclust,pch=20  ,main="PCA")
plot(ppms.pca$x[,1:2],col=ppms.kclust,pch=20  ,main="PCA")
text(ppms.pca$x[,1],ppms.pca$x[,2],datappm$Region,cex=.5)

```
Using tSNEA to reduce dimensionality:

```{r tsneafig,fig.cap="cluster using Tsne decomposition",out.width="50%",fig.show="hold"}

library(Rtsne)
ppms.tsne=Rtsne(ppms,pca=F)
ppms.dist=dist(ppms.tsne$Y)
ppms.clust=hclust(ppms.dist, method = "ward.D")
ppms.kclust=cutree(ppms.clust,k=13) #playing comparing community cluster vs simple hierarchical clustering
plot(ppms.tsne$Y[,1],ppms.tsne$Y[,2],col=rainbow(13)[ppms.kclust],pch=20,xlab="PC1",ylab="PC2")
plot(ppms.tsne$Y[,1],ppms.tsne$Y[,2],col=rainbow(13)[ppms.kclust],pch=20,xlab="PC1",ylab="PC2",main="tSNE")

plot(ppms.tsne$Y[,1],ppms.tsne$Y[,2],col=rainbow(13)[ppms.kclust],pch=20,main="tSNE")
text(ppms.tsne$Y[,1],ppms.tsne$Y[,2],datappm$Region,cex=.5)
```

```{r geoTsne,fig.cap="show cluster geographically"}
par(mar=rep(0,4))
library(rgdal)
country=c("BGD","CHN","IDN","IND","KHM","LAO","MMR","NPL","PHL","THA","VNM")
#for( m in country){
#    tmpm=readOGR(dsn = "Cartes/", layer=paste0(m,"_adm0") )
#    plot(tmpm,add=T,lwd=.1)
#}
allshapefiles=lapply(country,function(m) tmpm=readOGR(dsn = "Cartes/", layer=paste0(m,"_adm0") ))
seashapefile=do.call("rbind",allshapefiles)
plot(seashapefile,lwd=0.1)

datappm$Easting...Longitude= as.numeric(gsub("°","",datappm$Easting...Longitude))
datappm$Northing.Latitude= as.numeric(gsub("°","",datappm$Northing.Latitude))

points(datappm$Easting...Longitude,datappm$Northing.Latitude,col=rainbow(10,alpha=.5)[ppms.kclust],pch=2,cex=.8)
```

We now transform the result of the PCA as a graph, we compute edge weights as 
$$ \sqrt{\sum\frac{1}{d^2}} $$

```{r}

ppms.ew=1/(exp(as.matrix(ppms.dist)))
ppms.graph=graph.adjacency(ppms.ew, mode = "undirected", weighted = TRUE, diag = FALSE)
V(ppms.graph)$label=as.character(datappm$Country)
V(ppms.graph)$label.cex=.4
V(ppms.graph)$size=8
V(ppms.graph)$frame.color="black"
V(ppms.graph)$frame.width=.5
V(ppms.graph)$label.color=adjustcolor("black",.6)
E(ppms.graph)$color=NA
ppms.graph=set_graph_attr(ppms.graph,"layout",layout_with_fr(ppms.graph))
plot(ppms.graph)
```

Use this graph to  compute the communities

```{r louvain.new, results="asis",fig.cap="simple visualisation of the network with louvain communities. We label node given the site (left) and site + period (right)  where the artefact has been found.",out.width="50%"}
par(mar=c(0,0,0,0))
ppms.louvain=cluster_louvain(ppms.graph)
knitr::kable(sizes(ppms.louvain))
ncommu=length(sizes(ppms.louvain))

plot(ppms.graph,vertex.color=rainbow(ncommu,alpha=.6)[ppms.louvain$membership],vertex.label=NA)

plot(ppms.graph,vertex.color=rainbow(ncommu,alpha=.6)[ppms.louvain$membership])

```


Check if the communities correspond to some specific countries:

```{r,results="asis"}
count=table(cbind.data.frame(Country=V(ppms.graph)$label,community=ppms.louvain$membership))
knitr::kable(count)
```


### Geographical representation

Avec les shapefiles:

```{r out.width="100%",fig.cap="latlon"}
par(mar=c(0,0,0,0))
library(rgdal)
country=c("BGD","CHN","IDN","IND","KHM","LAO","MMR","NPL","PHL","THA","VNM")
#for( m in country){
#    tmpm=readOGR(dsn = "Cartes/", layer=paste0(m,"_adm0") )
#    plot(tmpm,add=T,lwd=.1)
#}
allshapefiles=lapply(country,function(m) tmpm=readOGR(dsn = "Cartes/", layer=paste0(m,"_adm0") ))
seashapefile=do.call("rbind",allshapefiles)
plot(seashapefile,lwd=0.1)
points(datappm$Easting...Longitude,datappm$Northing.Latitude,bg=rainbow(ncommu,alpha=.6)[ppms.louvain$membership],pch=21,ann=F,axes=F)
```

## Site Network

```{r}
joined=cbind(datappm,louvain=ppms.louvain$membership)
sites=unique(joined$Site)

system.time({
matdim1=sapply(sites,function(s1) sapply(sites,function(s2) simpmatch(joined$louvain[ joined$Site == s1],joined$louvain[ joined$Site == s2])))
})

system.time({
matdim2=matrix(NA,nrow=length(sites),ncol=length(sites))
for(s1 in 1:length(sites)){
    for(s2 in 1:length(sites)){
        c1=joined$louvain[ joined$Site == sites[s1]]
        c2=joined$louvain[ joined$Site == sites[s2]]
        matdim2[s1,s2]=simpmatch(c1,c2)
    }
}
})
sum(matdim2-matdim1)

sites.graph=graph.adjacency(matdim1, mode = "undirected", weighted = TRUE, diag = FALSE)
V(sites.graph)$label=as.character(sites)
V(sites.graph)$label.cex=.7
V(sites.graph)$size=8
V(sites.graph)$label.color="black"
E(sites.graph)$color=NA
sites.graph=set_graph_attr(sites.graph,"layout",layout_nicely(sites.graph))

```

visualise  communities of sites

```{r,out.width="100%"}
par(mar=c(0,0,0,0))
sites.communities=cluster_louvain(sites.graph)
comus=sites.communities$memberships[1,]

plot(sites.graph,vertex.color=rainbow(length(table(comus)),alpha=.6)[comus])
#plot(seashapefile,lwd=0.1)
#points(joined$Easting...Longitude,joined$Northing.Latitude ,pch=21,bg=rainbow(length(table(comus)),alpha=.6)[comus])

comus=sites.communities$memberships[2,]

plot(sites.graph,vertex.color=rainbow(length(table(comus)),alpha=.6)[comus])
#plot(seashapefile,lwd=0.1)
#points(joined$Easting...Longitude,joined$Northing.Latitude ,pch=21,bg=rainbow(length(table(comus)),alpha=.6)[comus])

```

Try with  communities of regions:

```{r}
joined=cbind(datappm,louvain=ppms.louvain$membership)
datappm=datappm[datappm$Region!="-",]
regions=unique(datappm$Region)

system.time({
matdim1=sapply(regions,function(s1) sapply(regions,function(s2) simpmatch(joined$louvain[ joined$Region == s1],joined$louvain[ joined$Region == s2])))
})

system.time({
matdim2=matrix(NA,nrow=length(regions),ncol=length(regions))
for(s1 in 1:length(regions)){
    for(s2 in 1:length(regions)){
        c1=joined$louvain[ joined$Region == regions[s1]]
        c2=joined$louvain[ joined$Region == regions[s2]]
        matdim2[s1,s2]=simpmatch(c1,c2)
    }
}
})
sum(matdim2-matdim1)

regions.graph=graph.adjacency(matdim1, mode = "undirected", weighted = TRUE, diag = FALSE)
V(regions.graph)$label=as.character(regions)
V(regions.graph)$label.cex=.7
V(regions.graph)$size=8
V(regions.graph)$label.color="black"
E(regions.graph)$color=NA
regions.graph=set_graph_attr(regions.graph,"layout",layout_nicely(regions.graph))

```

Compute communities of regions:

```{r,out.width="100%"}
par(mar=c(0,0,0,0))
regions.communities=cluster_louvain(regions.graph)
plot(regions.graph,vertex.color=rainbow(length(regions.communities),alpha=.6)[regions.communities$membership])
#plot(datappm$Easting...Longitude,datappm$Northing.Latitude ,pch=21,bg=rainbow(length(regions.communities),alpha=.6)[regions.communities$membership])
```

