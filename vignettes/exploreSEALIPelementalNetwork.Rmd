# New dataset


## Artefact Network

### Get Data


```{r}
datappm=read.csv("data/SEALIP_BROGLASEA data_compo_Pryce_V4.csv")

# set an arbitrary epsilon value and replace "tr"s and "0"s with it
epsilon=0.0001
datappm[,12:42]=apply(datappm[,12:42],2,function(i){i[i=="tr"]=epsilon;as.numeric(i)})
datappm[,12:42]=apply(datappm[,12:42],2,function(i){i[i=="nd"]=epsilon;as.numeric(i)})
datappm[,12:42]=apply(datappm[,12:42],2,function(i){i[i==0]=epsilon;as.numeric(i)})
datappm[,12:42]=apply(datappm[,12:42],2,function(i){i[is.na(i)]=epsilon;as.numeric(i)})


ppms=datappm[,12:42]
listelements=c("Sb","Sn","Ag","Mo","Bi","Pb","Se","As","Au","Zn","Cu","Ni","Co")
ppms=datappm[,listelements]
#ppms=ppms[,-7]
artnull=which(apply(ppms,1,sd)==0)
ttt=dist(ppms)
ttt=as.matrix(ttt)
dupli=which(apply(ttt,2,function(i)any(sum(i==0)>1)))
#artnull=c(222,289,296,299,531,172,181,531)
datappm=datappm[-artnull,]
datappm=datappm[-dupli,]
ppms=ppms[-artnull,]
ppms=ppms[-dupli,]
#plot(ppms,pch=20,cex=.7,col=adjustcolor(1,.2))

```

Check the correaltion between the elements' ppm

```{r,results="asis"}
knitr::kable(cor(ppms))
```

### Log transform

```{r}
ppms=as.data.frame(apply(ppms,2,log))
#plot(ppms,pch=20,cex=.7,col=adjustcolor(1,.2))
```

Check the correlations between ppms when log transformed

```{r,results="asis"}
knitr::kable(cor(ppms))
```

### PCA - dimeension reduction

Compute PCA scores:

```{r pcafig,fig.cap="cluster using directly the PCA result",out.width="50%"}
# remove eelement poorly detected
#ppms=ppms[,apply(ppms,2,function(i)sum(i==log(epsilon)))<(.4*nrow(ppms))]

ppms.pca=prcomp(ppms)
ppms.dist=dist(ppms.pca$x)
ppms.clust=hclust(ppms.dist)
ppms.kclust=cutree(ppms.clust,k=10) #playing comparing community cluster vs simple hierarchical clustering
plot(ppms.pca$x[,1:2],col=ppms.kclust,pch=20  )
plot(ppms.pca$x[,1:2],col=ppms.kclust,pch=20  ,main="PCA")
plot(ppms.pca$x[,1:2],col=ppms.kclust,pch=20  ,main="PCA")
text(ppms.pca$x[,1],ppms.pca$x[,2],datappm$Region,cex=.5)

```
Using tSNEA to reduce dimensionality:

```{r tsneafig,fig.cap="cluster using Tsne decomposition",out.width="50%",fig.show="hold"}

library(Rtsne)
ppms.tsne=Rtsne(ppms,pca=F)
ppms.dist=dist(ppms.tsne$Y)
ppms.clust=hclust(ppms.dist, method = "ward.D")
ppms.kclust=cutree(ppms.clust,k=13) #playing comparing community cluster vs simple hierarchical clustering
plot(ppms.tsne$Y[,1],ppms.tsne$Y[,2],col=rainbow(13)[ppms.kclust],pch=20,xlab="PC1",ylab="PC2")
plot(ppms.tsne$Y[,1],ppms.tsne$Y[,2],col=rainbow(13)[ppms.kclust],pch=20,xlab="PC1",ylab="PC2",main="tSNE")

plot(ppms.tsne$Y[,1],ppms.tsne$Y[,2],col=rainbow(13)[ppms.kclust],pch=20,main="tSNE")
text(ppms.tsne$Y[,1],ppms.tsne$Y[,2],datappm$Region,cex=.5)
```

```{r geoTsne,fig.cap="show cluster geographically"}
par(mar=rep(0,4))
library(rgdal)
seashapefile=readOGR(dsn = "Cartes/", layer=,"allsea") 
plot(seashapefile,lwd=0.1)

datappm$Easting...Longitude= as.numeric(gsub("°","",datappm$Easting...Longitude))
datappm$Northing.Latitude= as.numeric(gsub("°","",datappm$Northing.Latitude))

points(datappm$Easting...Longitude,datappm$Northing.Latitude,col=rainbow(10,alpha=.5)[ppms.kclust],pch=2,cex=.8)
```

We now transform the result of the PCA as a graph, we compute edge weights as 
$$ \sqrt{\sum\frac{1}{d^2}} $$

```{r}

ppms.ew=1/(exp(as.matrix(ppms.dist)))
ppms.graph=graph.adjacency(ppms.ew, mode = "undirected", weighted = TRUE, diag = FALSE)
V(ppms.graph)$label=as.character(datappm$Country)
V(ppms.graph)$label.cex=.4
V(ppms.graph)$size=8
V(ppms.graph)$frame.color="black"
V(ppms.graph)$frame.width=.5
V(ppms.graph)$label.color=adjustcolor("black",.6)
E(ppms.graph)$color=NA
ppms.graph=set_graph_attr(ppms.graph,"layout",layout_with_fr(ppms.graph))
plot(ppms.graph)
```

Use this graph to  compute the communities

```{r louvain.new, results="asis",fig.cap="simple visualisation of the network with louvain communities. We label node given the site (left) and site + period (right)  where the artefact has been found.",out.width="50%"}
par(mar=c(0,0,0,0))
ppms.louvain=cluster_louvain(ppms.graph)
knitr::kable(sizes(ppms.louvain))
ncommu=length(sizes(ppms.louvain))

plot(ppms.graph,vertex.color=rainbow(ncommu,alpha=.6)[ppms.louvain$membership],vertex.label=NA)

plot(ppms.graph,vertex.color=rainbow(ncommu,alpha=.6)[ppms.louvain$membership])

```


Check if the communities correspond to some specific countries:

```{r,results="asis"}
count=table(cbind.data.frame(Country=V(ppms.graph)$label,community=ppms.louvain$membership))
knitr::kable(count)
```


### Geographical representation

Avec les shapefiles:

```{r out.width="100%",fig.cap="latlon"}
par(mar=c(0,0,0,0))
plot(seashapefile,lwd=0.1)
points(datappm$Easting...Longitude,datappm$Northing.Latitude,bg=rainbow(ncommu,alpha=.6)[ppms.louvain$membership],pch=21,ann=F,axes=F)
```

## Site Network

```{r}
joined=cbind(datappm,louvain=ppms.louvain$membership)
sites=unique(joined$Site)

system.time({
matdim1=sapply(sites,function(s1) sapply(sites,function(s2) simpmatch(joined$louvain[ joined$Site == s1],joined$louvain[ joined$Site == s2])))
})

system.time({
matdim2=matrix(NA,nrow=length(sites),ncol=length(sites))
for(s1 in 1:length(sites)){
    for(s2 in 1:length(sites)){
        c1=joined$louvain[ joined$Site == sites[s1]]
        c2=joined$louvain[ joined$Site == sites[s2]]
        matdim2[s1,s2]=simpmatch(c1,c2)
    }
}
})
sum(matdim2-matdim1)

sites.graph=graph.adjacency(matdim1, mode = "undirected", weighted = TRUE, diag = FALSE)
V(sites.graph)$label=as.character(sites)
V(sites.graph)$label.cex=.7
V(sites.graph)$size=8
V(sites.graph)$label.color="black"
E(sites.graph)$color=NA
sites.graph=set_graph_attr(sites.graph,"layout",layout_nicely(sites.graph))

```

visualise  communities of sites

```{r,out.width="100%"}
par(mar=c(0,0,0,0))
sites.communities=cluster_louvain(sites.graph)
comus=sites.communities$memberships[1,]

plot(sites.graph,vertex.color=rainbow(length(table(comus)),alpha=.6)[comus])
#plot(seashapefile,lwd=0.1)
#points(joined$Easting...Longitude,joined$Northing.Latitude ,pch=21,bg=rainbow(length(table(comus)),alpha=.6)[comus])

comus=sites.communities$memberships[2,]

plot(sites.graph,vertex.color=rainbow(length(table(comus)),alpha=.6)[comus])
#plot(seashapefile,lwd=0.1)
#points(joined$Easting...Longitude,joined$Northing.Latitude ,pch=21,bg=rainbow(length(table(comus)),alpha=.6)[comus])

```

Try with  communities of regions:

```{r}
joined=cbind(datappm,louvain=ppms.louvain$membership)
datappm=datappm[datappm$Region!="-",]
regions=unique(datappm$Region)

system.time({
matdim1=sapply(regions,function(s1) sapply(regions,function(s2) simpmatch(joined$louvain[ joined$Region == s1],joined$louvain[ joined$Region == s2])))
})

system.time({
matdim2=matrix(NA,nrow=length(regions),ncol=length(regions))
for(s1 in 1:length(regions)){
    for(s2 in 1:length(regions)){
        c1=joined$louvain[ joined$Region == regions[s1]]
        c2=joined$louvain[ joined$Region == regions[s2]]
        matdim2[s1,s2]=simpmatch(c1,c2)
    }
}
})
sum(matdim2-matdim1)

regions.graph=graph.adjacency(matdim1, mode = "undirected", weighted = TRUE, diag = FALSE)
V(regions.graph)$label=as.character(regions)
V(regions.graph)$label.cex=.7
V(regions.graph)$size=8
V(regions.graph)$label.color="black"
E(regions.graph)$color=NA
regions.graph=set_graph_attr(regions.graph,"layout",layout_nicely(regions.graph))

```

Compute communities of regions:

```{r,out.width="100%"}
par(mar=c(0,0,0,0))
regions.communities=cluster_louvain(regions.graph)
plot(regions.graph,vertex.color=rainbow(length(regions.communities),alpha=.6)[regions.communities$membership])
#plot(datappm$Easting...Longitude,datappm$Northing.Latitude ,pch=21,bg=rainbow(length(regions.communities),alpha=.6)[regions.communities$membership])
```


